# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uzhw4t7jCy0OiNpbu5y7pBpnF7sGwAZz

## **Advanced Time Series Forecasting with State Space Models and Kalman Filtering**
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from statsmodels.tsa.statespace.sarimax import SARIMAX
from scipy.linalg import inv


def generate_synthetic_data(T=200, seed=42):
    np.random.seed(seed)

    sigma_level = 0.5
    sigma_trend = 0.1
    sigma_season = 0.3
    sigma_obs = 1.0
    seasonal_period = 12

    level = np.zeros(T)
    trend = np.zeros(T)
    season = np.zeros((seasonal_period, T))


    level[0] = 10
    trend[0] = 0.1
    season[:, 0] = np.sin(np.linspace(0, 2*np.pi, seasonal_period))


    for t in range(1, T):
        level[t] = level[t-1] + trend[t-1] + np.random.normal(0, sigma_level)
        trend[t] = trend[t-1] + np.random.normal(0, sigma_trend)
        season[:, t] = np.roll(season[:, t-1], 1) + np.random.normal(0, sigma_season, seasonal_period)

    y = np.zeros(T)
    for t in range(T):
        y[t] = level[t] + season[t % seasonal_period, t] + np.random.normal(0, sigma_obs)

    return y, level, trend, season, (sigma_level, sigma_trend, sigma_season, sigma_obs
def construct_ssm_matrices(seasonal_period=12):

    n_state = 2 + (seasonal_period - 1)

    F = np.eye(n_state)
    F[0,0] = 1
    F[0,1] = 1
    F[1,1] = 1

    for i in range(2, n_state-1):
        F[i, i+1] = 1
    F[n_state-1, 2] = 1


    H = np.zeros((1, n_state))
    H[0,0] = 1
    H[0,2:] = 1

    return F, H


class KalmanFilter:
    def __init__(self, F, H, Q, R, x0, P0):
        self.F = F
        self.H = H
        self.Q = Q
        self.R = R
        self.x = x0
        self.P = P0

    def predict(self):
        self.x = self.F @ self.x
        self.P = self.F @ self.P @ self.F.T + self.Q

    def update(self, y):
        S = self.H @ self.P @ self.H.T + self.R
        K = self.P @ self.H.T @ inv(S)
        y_pred = self.H @ self.x
        self.x = self.x + K @ (y - y_pred)
        self.P = (np.eye(self.P.shape[0]) - K @ self.H) @ self.P
        return y_pred, S


def EM_algorithm(y, F, H, n_iter=10):
    n_state = F.shape[0]
    n_obs = len(y)

    # Initialize parameters (variances)
    sigma_level = 1.0
    sigma_trend = 1.0
    sigma_season = 1.0
    sigma_obs = 1.0

    # Initialize covariance matrices Q and R
    Q = np.diag([sigma_level, sigma_trend] + [sigma_season]*(n_state-2))
    R = np.array([[sigma_obs]])

    # Initial state and covariance
    x0 = np.zeros(n_state)
    P0 = np.eye(n_state) * 1.0

    for iteration in range(n_iter):
        # Run Kalman filter and smoother
        kf = KalmanFilter(F, H, Q, R, x0, P0)
        x_filtered = []
        P_filtered = []

        # Forward pass
        for t in range(n_obs):
            kf.predict()
            y_pred, S = kf.update(np.array([y[t]]))
            x_filtered.append(kf.x.copy())
            P_filtered.append(kf.P.copy())

        # Brief EM update for Q and R (simplified - full requires Kalman smoother)
        x_filtered = np.array(x_filtered)

        # Estimate variances from innovations
        residuals = y - (x_filtered @ H.T).flatten()
        sigma_obs = np.var(residuals)
        Q = np.diag([sigma_level, sigma_trend] + [sigma_season]*(n_state-2))
        R = np.array([[sigma_obs]])

        print(f"Iteration {iteration+1}: sigma_obs = {sigma_obs:.4f}")

    return Q, R

# --- Forecasting with State Space Model ---
def state_space_forecast(y, F, H, Q, R, steps=12):
    n_state = F.shape[0]
    x0 = np.zeros(n_state)
    P0 = np.eye(n_state)

    kf = KalmanFilter(F, H, Q, R, x0, P0)

    # Filter through data
    for t in range(len(y)):
        kf.predict()
        kf.update(np.array([y[t]]))

    # Forecast
    forecasts = []
    x_forecast = kf.x.copy()
    P_forecast = kf.P.copy()

    for _ in range(steps):
        x_forecast = F @ x_forecast
        P_forecast = F @ P_forecast @ F.T + Q
        y_forecast = H @ x_forecast
        forecasts.append(y_forecast.item())

    return np.array(forecasts)

# --- Baseline SARIMA model forecast ---
def sarima_forecast(y, steps=12):
    model = SARIMAX(y, order=(1,1,1), seasonal_order=(1,1,0,12))
    result = model.fit(disp=False)
    forecast = result.forecast(steps)
    return forecast

# --- Performance Metrics ---
def compute_metrics(true, pred):
    rmse = np.sqrt(np.mean((true - pred)**2))
    mae = np.mean(np.abs(true - pred))
    mape = np.mean(np.abs((true - pred)/true)) * 100
    return rmse, mae, mape

# --- Main Execution ---
if __name__ == "__main__":
    # Generate synthetic data
    y, level, trend, season, true_params = generate_synthetic_data(T=200)
    train, test = y[:180], y[180:]

    # Construct state space matrices
    F, H = construct_ssm_matrices(seasonal_period=12)

    # EM to estimate parameters Q, R
    Q, R = EM_algorithm(train, F, H, n_iter=10)

    # Forecast with state space model
    ssm_forecast = state_space_forecast(train, F, H, Q, R, steps=len(test))

    # Baseline SARIMA forecast
    sarima_pred = sarima_forecast(train, steps=len(test))

    # Metrics
    rmse_ssm, mae_ssm, mape_ssm = compute_metrics(test, ssm_forecast)
    rmse_sarima, mae_sarima, mape_sarima = compute_metrics(test, sarima_pred)

    # Plot results
    plt.figure(figsize=(12,6))
    plt.plot(range(len(y)), y, label='True Data')
    plt.plot(range(180, 200), ssm_forecast, label='State Space Forecast')
    plt.plot(range(180, 200), sarima_pred, label='SARIMA Forecast')
    plt.legend()
    plt.title("Forecast Comparison")
    plt.show()

    print("State Space Model Forecast Performance:")
    print(f"RMSE: {rmse_ssm:.4f}, MAE: {mae_ssm:.4f}, MAPE: {mape_ssm:.2f}%")
    print("
SARIMA Forecast Performance:")
    print(f"RMSE: {rmse_sarima:.4f}, MAE: {mae_sarima:.4f}, MAPE: {mape_sarima:.2f}%")